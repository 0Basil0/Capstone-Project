{% extends 'base.html' %}
{% load i18n %}
{% block title %}{% trans "AI Chat" %}{% endblock %}
{% block content %}
<div class="container fade-in-up ">
<div class="row">
  <div class="col-md-4">
    <div class="d-flex justify-content-between align-items-center mb-2">
  <h5 class="font-weight-bold green_withshadow">{% trans "Conversations" %}</h5>
  <button class="btn btn-sm btn-primary" id="newChatBtn">{% trans "New Chat" %}</button>
    </div>

    <!-- Avatar display (uploads moved to Edit profile page) -->
    <div class="mb-3 d-flex align-items-center gap-2">
      {% if profile and profile.avatar %}
        <div class="circle-transparent chat-avatar">
            <img src="{{ profile.avatar.url }}" alt="avatar">
        </div>
      {% else %}
        <div class="circle-transparent chat-avatar d-inline-flex align-items-center justify-content-center" style="font-weight:600">{% if profile %}{{ profile.initials }}{% else %}{{ user.username|slice:":1"|upper }}{% endif %}</div>
      {% endif %}

    </div>
    <div id="conversations" class="list-group" style="max-height:70vh; overflow:auto;">
      {% for chat in chats %}
        <a href="#" class="list-group-item list-group-item-action chat-item" data-session-id="{{ chat.session_id }}">
          <div class="d-flex w-100 justify-content-between">
            <h6 class="mb-1 small text-truncate">{{ chat.first_message|default:'(empty)'|truncatechars:60 }}</h6>
            <small class="text-muted">{{ chat.last_timestamp|date:"M d, H:i" }}</small>
          </div>
          <p class="mb-1 small text-muted text-truncate">{{ chat.preview|default:'' }}</p>
        </a>
        
      {% empty %}
        <div class="text-muted small">{% trans "No conversations yet. Click \"New Chat\" to start." %}</div>
      {% endfor %}
    </div>
  </div>

  <div class="col-md-8">
    <div class="card chat-card" style="height:75vh; display:flex; flex-direction:column;">
      <div class="card-body p-3" id="chatPane" style="overflow:auto; flex:1 1 auto;">
        <div id="messages" class="mb-2"></div>
      </div>

      <div class="card-footer chat-footer">
        <div class="input-group">
          <input type="text" id="userMessage" class="form-control" placeholder="{% trans "Type your question..." %}">
          <button class="btn btn-success" id="sendBtn">{% trans "Send" %}</button>
          <button class="btn btn-outline-danger" id="deleteBtn">{% trans "Delete" %}</button>
        </div>
      </div>
    </div>
  </div>
<script>
// JS translations for dialog text
const I18N = {
  delete_confirm: '{% trans "Delete this conversation?" %}',
  error_label: '{% trans "Error:" %}'
};

</div>
</div>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<!-- DOMPurify for sanitizing rendered HTML from markdown to prevent XSS -->
<script src="https://cdn.jsdelivr.net/npm/dompurify@2.4.0/dist/purify.min.js"></script>

<script>
function getCookie(name) { let v = document.cookie.match('(^|;)\\s*'+name+'\\s*=\\s*([^;]+)'); return v ? v.pop() : ''; }
const csrfToken = getCookie('csrftoken');
const profileAvatarUrl = {% if profile and profile.avatar %}'{{ profile.avatar.url }}'{% else %}null{% endif %};
const profileInitials = {% if profile %}'{{ profile.initials }}'{% else %}'{{ user.username|slice:":1"|upper }}'{% endif %};
let currentChatId = null;
let isNewSession = false; // true when user clicked New Chat and the next send should create a sidebar entry

async function loadConversations() {
  // conversation list already rendered server-side; just attach handlers
  document.querySelectorAll('.chat-item').forEach(el => attachChatItemHandler(el));
}

function attachChatItemHandler(el) {
  // remove existing listener by cloning and replacing to avoid duplicate handlers
  const newEl = el.cloneNode(true);
  el.parentNode.replaceChild(newEl, el);
  newEl.addEventListener('click', async (e) => {
    e.preventDefault();
    const sid = newEl.dataset.sessionId;
    isNewSession = false;
    await selectChat(sid);
  });
}

async function selectChat(sessionId) {
  currentChatId = sessionId;
  // fetch chat details for session
  const res = await fetch(`{% url 'chat_get' '00000000-0000-0000-0000-000000000000' %}`.replace('00000000-0000-0000-0000-000000000000', sessionId), { credentials: 'same-origin' });
  const data = await res.json();
  
  const messages = document.getElementById('messages');
  messages.innerHTML = '';
  // server returns the full message list for the session
    for (const m of data.messages) {
      
      // user message bubble with avatar/initials
      const userAvatarHtml = profileAvatarUrl ? (`<img src="${profileAvatarUrl}" class="rounded-circle" width="32" height="32" style="object-fit:cover;margin-right:8px;">`) : (`<div class="rounded-circle bg-secondary text-white d-inline-flex align-items-center justify-content-center" style="width:32px;height:32px;font-weight:600;margin-right:8px;">${profileInitials}</div>`);
      // user bubble
      messages.innerHTML += `<div class="msg-row user"><div class="chat-bubble user">${renderMessage(m.user_message)}</div><div class="meta">${userAvatarHtml}</div></div>`;
      // ai bubble
      messages.innerHTML += `<div class="msg-row"><div class="meta"></div><div class="chat-bubble ai">${renderMessage(m.bot_response)}</div></div>`;
    }
  scrollChatToBottom();
}

async function sendMessage() {
  const input = document.getElementById('userMessage');
  const message = input.value.trim();
  if (!message) return;

  // show optimistic user message
  const messages = document.getElementById('messages');
  const userAvatarHtml = profileAvatarUrl ? (`<img src="${profileAvatarUrl}" class="rounded-circle" width="32" height="32" style="object-fit:cover;margin-right:8px;">`) : (`<div class="rounded-circle bg-secondary text-white d-inline-flex align-items-center justify-content-center" style="width:32px;height:32px;font-weight:600;margin-right:8px;">${profileInitials}</div>`);
  messages.innerHTML += `<div class="msg-row user"><div class="chat-bubble user">${renderMessage(message)}</div><div class="meta">${userAvatarHtml}</div></div>`;
  scrollChatToBottom();

  const res = await fetch("{% url 'chatbot_api' %}", {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-CSRFToken': csrfToken,
    },
    body: JSON.stringify({ message, session_id: currentChatId })
  });
  const data = await res.json();
  if (data.error) {
    messages.innerHTML += `<div class="text-danger"><strong>Error:</strong> ${escapeHtml(data.error)}</div>`;
  } else {
  messages.innerHTML += `<div class="msg-row"><div class="meta"></div><div class="chat-bubble ai">${renderMessage(data.reply)}</div></div>`;
    // set or update the active session id
    if (data.session_id) {
      // Set current session
      const sid = data.session_id;
      if (isNewSession) {
        currentChatId = sid;
        addConversationToSidebar(sid, message, data.reply);
        isNewSession = false;
      } else {
        // existing session â€” update preview/time
        currentChatId = sid;
        const updated = updateConversationEntry(sid, message, data.reply);
        if (!updated) {
          // fallback: add if no existing element
          addConversationToSidebar(sid, message, data.reply);
        }
      }
    }
  }
  input.value = '';
  scrollChatToBottom();
}

function addConversationToSidebar(id, userMsg, botResp) {
  const container = document.getElementById('conversations');
  // If entries for this session already exist, keep only the first and remove duplicates
  const selector = `.chat-item[data-session-id="${id}"]`;
  const existingNodes = Array.from(container.querySelectorAll(selector));
  let existing = existingNodes.length > 0 ? existingNodes[0] : null;
  if (existingNodes.length > 1) {
    // remove duplicates beyond the first
    for (let i = 1; i < existingNodes.length; i++) {
      existingNodes[i].remove();
    }
  }
  const html = `<div style="display:flex;align-items:center;gap:8px;"><div class=\"conversation-circle\">${escapeHtml(userMsg || '').charAt(0) || 'C'}</div><div><div style=\"font-weight:700;\">${escapeHtml(userMsg).substring(0,20)}</div><div class=\"preview\">${escapeHtml(botResp).substring(0,60)}</div></div></div>`;
  if (existing) {
  // update content
  existing.innerHTML = html;
  // move to top
  container.prepend(existing);
  // reattach handler to ensure it's correct
  attachChatItemHandler(existing);
  } else {
  const a = document.createElement('a');
  a.className = 'list-group-item list-group-item-action chat-item active';
  a.dataset.sessionId = id;
  a.href = '#';
  a.innerHTML = html;
    // prepend and attach handler
    container.prepend(a);
    attachChatItemHandler(a);
  }
  // set as current and load messages
  selectChat(id);
}

function updateConversationEntry(id, userMsg, botResp) {
  const container = document.getElementById('conversations');
  const selector = `.chat-item[data-session-id="${id}"]`;
  const existingNodes = Array.from(container.querySelectorAll(selector));   
  if (existingNodes.length === 0) return false;
  const existing = existingNodes[0];
  // Update preview paragraph
  const previewP = existing.querySelector('p');
  if (previewP) previewP.textContent = botResp ? botResp.substring(0, 120) + (botResp.length > 120 ? '...' : '') : '';
  const small = existing.querySelector('small');
  if (small) small.textContent = 'Now';
  
  container.prepend(existing);
  attachChatItemHandler(existing);
  return true;
}

async function deleteCurrentChat() {
  if (!currentChatId) return;
  if (!confirm('Delete this conversation?')) return;
  const res = await fetch(`{% url 'chat_delete' '00000000-0000-0000-0000-000000000000' %}`.replace('00000000-0000-0000-0000-000000000000', `${currentChatId}`), {
    method: 'POST', credentials: 'same-origin', headers: {'X-CSRFToken': csrfToken}
  });
  const data = await res.json();
  if (data.deleted) {
    const el = document.querySelector(`.chat-item[data-session-id="${currentChatId}"]`);
    if (el) el.remove();
    currentChatId = null;
    document.getElementById('messages').innerHTML = '';
  }
}

function newChat() {
  currentChatId = null;
  isNewSession = true;
  document.getElementById('messages').innerHTML = '';
}

function scrollChatToBottom() {
  const pane = document.getElementById('chatPane');
  pane.scrollTop = pane.scrollHeight;
}

function escapeHtml(text) {
  var map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
  return String(text).replace(/[&<>\"']/g, function(m) { return map[m]; });
}

// Prefer marked + DOMPurify, but fall back to a safe inline-processor that
// preserves code spans/blocks and converts **bold**/*italic* when needed.
function renderMessage(text){
  if (text === null || text === undefined) return '';
  try{
    const raw = String(text||'');
    // Internal fallback processor: preserves code spans/blocks and converts **bold**/*italic*
    function fallbackProcess(input){
      try{
        // Remove a wider set of invisible/formatting characters that appear in
        // RTL/Arabic text and can break regex-based markdown parsing.
        const rawNorm = input.replace(/[\u200E\u200F\u202A-\u202E\u2066-\u2069\u061C\u200B\u200C\u200D\uFEFF\u2060]/g,'');
        const tokens = [];
        let withPlaceholders = rawNorm.replace(/```([\s\S]*?)```/g, function(_, code){
          const id = tokens.length; tokens.push('<pre><code>'+escapeHtml(code)+'</code></pre>'); return '@@CODE'+id+'@@';
        });
        withPlaceholders = withPlaceholders.replace(/`([^`]+?)`/g, function(_, code){ const id = tokens.length; tokens.push('<code>'+escapeHtml(code)+'</code>'); return '@@CODE'+id+'@@'; });
        const parts = withPlaceholders.split(/(@@CODE\d+@@)/g);
        for(let i=0;i<parts.length;i++){ if(!/^@@CODE\d+@@$/.test(parts[i])) parts[i]=escapeHtml(parts[i]); }
        let esc = parts.join('');
        // Use [\s\S] to allow matching across newlines and be more robust for emphasis.
        esc = esc.replace(/\*\*([\s\S]+?)\*\*/g,'<strong>$1</strong>');
        esc = esc.replace(/\*([\s\S]+?)\*/g,'<em>$1</em>');

        // Handle block-level markdown (headings and lists) on the escaped text.
        const lines = esc.split(/\r?\n/);
        const out = [];
        for (let i = 0; i < lines.length; ) {
          const line = lines[i];
          // Headings: #, ##, ### ... up to 6
          const h = line.match(/^(#{1,6})\s+(.*)$/);
          if (h) {
            const level = Math.min(h[1].length, 6);
            out.push(`<h${level}>${h[2]}</h${level}>`);
            i++;
            continue;
          }

          // Lists: gather consecutive list lines into a single <ul> or <ol>
          const ulMatch = line.match(/^\s*([-\*])\s+(.*)$/);
          const olMatch = line.match(/^\s*(\d+)\.\s+(.*)$/);
          if (ulMatch || olMatch) {
            const isOrdered = !!olMatch;
            const items = [];
            while (i < lines.length && (lines[i].match(/^\s*([-\*])\s+/) || lines[i].match(/^\s*\d+\.\s+/))) {
              const liLine = lines[i].replace(/^\s*([-\*]|\d+\.)\s+/, '');
              items.push(`<li>${liLine}</li>`);
              i++;
            }
            out.push(isOrdered ? `<ol>${items.join('')}</ol>` : `<ul>${items.join('')}</ul>`);
            continue;
          }

          // Regular line
          out.push(line);
          i++;
        }

        const restored = out.join('\n').replace(/@@CODE(\d+)@@/g,function(_, idx){ return tokens[Number(idx)]; });
        const finalHtml = restored.replace(/\n/g,'<br>');
        return (typeof DOMPurify !== 'undefined') ? DOMPurify.sanitize(finalHtml) : finalHtml;
      }catch(e){ return escapeHtml(String(input)).replace(/\n/g,'<br>'); }
    }

    // Always use our internal fallback processor which covers bold/italic,
    // inline code and fenced code blocks and tolerates RTL invisible chars.
    // If marked is available it may be used for richer markdown in the future,
    // but fallback guarantees the essential formatting works even if CDN fails.
    return fallbackProcess(raw);
  }catch(e){
    return escapeHtml(String(text)).replace(/\n/g,'<br>');
  }
}

document.getElementById('sendBtn').addEventListener('click', sendMessage);
document.getElementById('userMessage').addEventListener('keydown', function(e){ if(e.key === 'Enter') { sendMessage(); }});
document.getElementById('deleteBtn').addEventListener('click', deleteCurrentChat);
document.getElementById('newChatBtn').addEventListener('click', newChat);

loadConversations();
</script>


{% endblock %}
