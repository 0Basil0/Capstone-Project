from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import ListView,  CreateView
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth import logout
from .forms import CustomUserCreationForm
from .models import ChatHistory, Allergy, MealPlan, Food
from django.db.models import Max
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.http import JsonResponse
import json
import os
from google import genai
from django.views.decorators.http import require_POST
from .utils import generate_daily_meals , generate_image
import datetime
import glob
import re
from django.db import connection, transaction, DatabaseError
 


class SignUpView(CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

def custom_logout(request):
    logout(request)
    return redirect('login')


@login_required
def post_login(request):
    # If user has no allergies recorded, send them to survey; otherwise go home
    if not Allergy.objects.filter(user=request.user).exists():
        return redirect('survey')
    return redirect('home')     


@login_required
def survey(request):
    return render(request, 'survey.html')


@login_required
def chatbot_api(request):
    if request.method == "POST":
        # Set API key in environment variable 
        os.environ["GEMINI_API_KEY"] = "AIzaSyBYsuwdWzG5Vm70uJ_AuzKljDES4FpUxyA"

        # Get user message...
        try:
            payload_json = json.loads(request.body)
            user_message = payload_json.get('message')
        except Exception:
            user_message = request.POST.get('message')
        if not user_message:
            return JsonResponse({"error": "No message provided"}, status=400)

        client = genai.Client()
        # Log user message...
        try:
            response = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=[{"parts": [{"text": user_message}]}],
            )

            reply = response.text
            if not reply:
                reply = str(response)

            # allow client to supply a session_id for continuing a conversation
            session_id = None
            try:
                payload = json.loads(request.body)
                session_id = payload.get('session_id')
            except Exception:
                session_id = request.POST.get('session_id')

            # Create a new ChatHistory row; if session_id provided, use it, else a new uuid is generated by model
            if session_id:
                chat = ChatHistory.objects.create(user=request.user, session_id=session_id, user_message=user_message, bot_response=reply)
            else:
                chat = ChatHistory.objects.create(user=request.user, user_message=user_message, bot_response=reply)

            return JsonResponse({"reply": reply, "session_id": str(chat.session_id)})
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=502)

@login_required
@require_POST
def survey_submit(request):
    # Process survey fields and save to DB
    first = request.POST.get('question1')
    allergies_text = request.POST.get('question5')

    user = request.user
    # Save allergies
    if allergies_text:
        names = [n.strip() for n in allergies_text.split(',') if n.strip()]
        from .utils import generate_allergy_description
        for name in names:
            try:
                desc = generate_allergy_description(name)
                obj, created = Allergy.objects.get_or_create(user=user, name=name, defaults={'description': desc})
                if not created and not obj.description and desc:
                    obj.description = desc
                    obj.save()
            except Allergy.MultipleObjectsReturned:
                qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                first = qs.first()
                qs.exclude(pk=first.pk).delete()
                if first and not first.description:
                    desc = generate_allergy_description(name)
                    if desc:
                        first.description = desc
                        first.save()

    return redirect('allergies')

@login_required
def base(request):
    return render (request, 'base.html')
@login_required
def home(request):
    return render (request, 'home.html')
class chatView(LoginRequiredMixin, ListView):
    model = ChatHistory
    
    template_name = 'chat_form.html'
    context_object_name = 'chats'

    # Get distinct session_ids and order them by the most recent message timestamp per session
    def get(self, request, *args, **kwargs):
        
        sessions = (
            ChatHistory.objects.filter(user=request.user)
            .values('session_id')
            .annotate(last_ts=Max('timestamp'))
            .order_by('-last_ts')
        )

        summaries = []
        for s in sessions:
            sid = s['session_id']
            entries = ChatHistory.objects.filter(user=request.user, session_id=sid).order_by('timestamp')
            if not entries.exists():
                continue
            first = entries.first()
            last = entries.last()

            preview_text = (last.bot_response or last.user_message or '')
            if len(preview_text) > 80:
                preview_text = preview_text[:77] + '...'

            summaries.append({
                'session_id': str(sid),
                'first_message': first.user_message,
                'preview': preview_text,
                'last_timestamp': last.timestamp,
            })

        return render(request, self.template_name, {'chats': summaries})
class AllergyListView(LoginRequiredMixin, ListView):
    model = Allergy
    
    
    template_name = 'allergies_form.html'
    context_object_name = 'allergies'
    def get_queryset(self):
        return Allergy.objects.filter(user=self.request.user)


@login_required
def home(request):
    # Show today's meal placeholders and existing mealplans for user
    day = datetime.date.today().isoformat()

    # Avoid selecting all MealPlan columns (some DBs may be missing new columns like generation_count).
    plan_vals = MealPlan.objects.filter(user=request.user, day=day).values('breakfast_id', 'lunch_id', 'dinner_id').first()

    initial_plan = None
    if plan_vals:
        user_slug = request.user.username
        base_dir = os.path.dirname(os.path.abspath(__file__))
        images_base = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)
        import glob

        def image_url_if_exists_for_meal(meal_suffix):
            pattern = os.path.join(images_base, f"{day}_*_{meal_suffix}.png")
            matches = glob.glob(pattern)
            if not matches:
                legacy = os.path.join(images_base, f"{day}_{meal_suffix}.png")
                if os.path.exists(legacy):
                    return f"/static/images/generated/{user_slug}/{day}_{meal_suffix}.png"
                return None
            latest = max(matches, key=os.path.getmtime)
            fname = os.path.basename(latest)
            return f"/static/images/generated/{user_slug}/{fname}"

        # Load Food objects by id (these are safe to query)
        breakfast = Food.objects.filter(pk=plan_vals.get('breakfast_id')).first() if plan_vals.get('breakfast_id') else None
        lunch = Food.objects.filter(pk=plan_vals.get('lunch_id')).first() if plan_vals.get('lunch_id') else None
        dinner = Food.objects.filter(pk=plan_vals.get('dinner_id')).first() if plan_vals.get('dinner_id') else None

        def strip_timestamp_suffix(name):
            if not name:
                return ''
            # remove trailing space + 14-digit timestamp (YYYYMMDDHHMMSS)
            return re.sub(r"\s*\d{14}$", '', name)

        initial_plan = {
            'breakfast': {
                'name': strip_timestamp_suffix(breakfast.name) if breakfast else '',
                'image': image_url_if_exists_for_meal('breakfast'),
                'ingredients': breakfast.ingredients if breakfast else '',
                'description': breakfast.description if breakfast else '',
            },
            'lunch': {
                'name': strip_timestamp_suffix(lunch.name) if lunch else '',
                'image': image_url_if_exists_for_meal('lunch'),
                'ingredients': lunch.ingredients if lunch else '',
                'description': lunch.description if lunch else '',
            },
            'dinner': {
                'name': strip_timestamp_suffix(dinner.name) if dinner else '',
                'image': image_url_if_exists_for_meal('dinner'),
                'ingredients': dinner.ingredients if dinner else '',
                'description': dinner.description if dinner else '',
            },
            'generation_count': 0,
        }

    import json
    initial_plan_json = json.dumps(initial_plan) if initial_plan else None
    return render(request, 'home.html', {'initial_plan': initial_plan, 'initial_plan_json': initial_plan_json})


@login_required
@require_POST
def generate_and_save_meals(request):
    # Generate daily meals via AI and save them as Food + MealPlan for today


    allergy_names = list(Allergy.objects.filter(user=request.user).values_list('name', flat=True))
    meals_today = list(MealPlan.objects.filter(user=request.user).values_list('breakfast__name', 'lunch__name', 'dinner__name'))
    day = datetime.date.today().isoformat()
    data = generate_daily_meals(allergy_names=allergy_names, meals_today=meals_today)
    if not data:
        return JsonResponse({'error': 'Could not generate meals'}, status=502)

    # Helper to always create a new Food record for each generation so images and
    # DB entries are fresh every time the user clicks Generate.
    def create_new_food(obj):
        if not obj:
            return None
        # Keep the stored/display name clean (no timestamp suffix). The timestamp
        # will be used only for image filenames.
        raw_name = obj.get('name','').strip()[:100]
        ingredients = obj.get('ingredients','')
        description = obj.get('description','')
        food = Food.objects.create(name=raw_name, ingredients=ingredients, description=description)
        return food

    # Use a timestamp so each generation writes new image files
    ts = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    breakfast = create_new_food(data.get('breakfast', {})) if data.get('breakfast') else None
    lunch = create_new_food(data.get('lunch', {})) if data.get('lunch') else None
    dinner = create_new_food(data.get('dinner', {})) if data.get('dinner') else None
    print("Generated meals:", breakfast, lunch, dinner)

    # Generate background images for each meal and save into static/images/generated/<user>/<day>_
    user_slug = request.user.username
    day = datetime.date.today().isoformat()
    images = {}
    try:
        # ensure user's image directory exists
        base_dir = os.path.dirname(os.path.abspath(__file__))
        images_folder = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)
        os.makedirs(images_folder, exist_ok=True)

        # Helper to find the most recent timestamped image for a given meal.


        def image_url_if_exists_for_meal(meal_suffix):
            # meal_suffix expected like 'breakfast' or 'lunch' or 'dinner'
            pattern = os.path.join(images_folder, f"{day}_*_{meal_suffix}.png")
            matches = glob.glob(pattern)
            if not matches:
                # fallback to previous non-timestamped name
                legacy = os.path.join(images_folder, f"{day}_{meal_suffix}.png")
                if os.path.exists(legacy):
                    return f"/static/images/generated/{user_slug}/{day}_{meal_suffix}.png"
                return None
            # pick the most recently modified file
            latest = max(matches, key=os.path.getmtime)
            fname = os.path.basename(latest)
            return f"/static/images/generated/{user_slug}/{fname}"
        if breakfast:
            prompt = f"{breakfast.name}: {breakfast.ingredients}. {breakfast.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_breakfast.png"
            images['breakfast_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['breakfast_img'] = None
        if lunch:
            prompt = f"{lunch.name}: {lunch.ingredients}. {lunch.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_lunch.png"
            images['lunch_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['lunch_img'] = None
        if dinner:
            prompt = f"{dinner.name}: {dinner.ingredients}. {dinner.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_dinner.png"
            images['dinner_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['dinner_img'] = None
    except Exception:
        images = {'breakfast_img': None, 'lunch_img': None, 'dinner_img': None}

    day = datetime.date.today().isoformat()
    plan, created = MealPlan.objects.get_or_create(user=request.user, day=day)
    plan.breakfast = breakfast
    plan.lunch = lunch
    plan.dinner = dinner
    # increment generation counter if field exists
    try:
        plan.generation_count = (plan.generation_count or 0) + 1
    except Exception:
        # if field missing or not available, ignore
        pass
    plan.save()

    # Return JSON with saved plan info
    return JsonResponse({
        'day': day,
        'breakfast': {
            'id': breakfast.id if breakfast else None,
            'name': breakfast.name if breakfast else '',
            'image': images.get('breakfast_img'),
            'ingredients': breakfast.ingredients if breakfast else '',
            'description': breakfast.description if breakfast else '',
        },
        'lunch': {
            'id': lunch.id if lunch else None,
            'name': lunch.name if lunch else '',
            'image': images.get('lunch_img'),
            'ingredients': lunch.ingredients if lunch else '',
            'description': lunch.description if lunch else '',
        },
        'dinner': {
            'id': dinner.id if dinner else None,
            'name': dinner.name if dinner else '',
            'image': images.get('dinner_img'),
            'ingredients': dinner.ingredients if dinner else '',
            'description': dinner.description if dinner else '',
        },
    })
        


@login_required
def chat_get(request, session_id):
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id).order_by('timestamp')
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    messages = []
    for chat in qs:
        messages.append({
            "id": chat.id,
            "user_message": chat.user_message,
            "bot_response": chat.bot_response,
            "timestamp": chat.timestamp.isoformat(),
        })
    return JsonResponse({"session_id": str(session_id), "messages": messages})


@login_required
@require_POST
def chat_delete(request, session_id):
    # Delete all chat history items in a session belonging to the user.
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id)
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    qs.delete()
    return JsonResponse({"deleted": True})

@login_required
def add_allergy(request):
    allergies_text = request.POST.get('allergies')  
    user = request.user
    # Save allergies..
    if allergies_text:
            names = [n.strip() for n in allergies_text.split(',') if n.strip()]
            from .utils import generate_allergy_description
            for name in names:
                try:
                    desc = generate_allergy_description(name)
                    obj, created = Allergy.objects.get_or_create(user=user, name=name, defaults={'description': desc})
                    if not created and not obj.description and desc:
                        obj.description = desc
                        obj.save()
                except Allergy.MultipleObjectsReturned:
                    qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                    first = qs.first()
                    qs.exclude(pk=first.pk).delete()
                    if first and not first.description:
                        desc = generate_allergy_description(name)
                        if desc:
                            first.description = desc
                            first.save()
    return redirect('allergies')


@login_required
@require_POST
def delete_allergy(request, pk):
    # Only allow owner to delete
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    # to delete rows from the (possibly-missing) many-to-many join table.
    try:
        with transaction.atomic():
            with connection.cursor() as cursor:
                cursor.execute(
                    'DELETE FROM main_app_allergy WHERE id = %s AND user_id = %s',
                    [allergy.id, request.user.id]
                )
        return redirect('allergies')
    except DatabaseError as e:
        # If SQL fails, fall back to ORM delete (this may still raise the original ProgrammingError)
        try:
            allergy.delete()
        except Exception as e2:
            return JsonResponse({"error": str(e2)}, status=400)
        return redirect('allergies')


@login_required
def edit_allergy(request, pk):

    # Only allow owner to edit
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    if request.method == "POST":
        name = request.POST.get('name')
        description = request.POST.get('description')
        if name:
            allergy.name = name
        if description:
            allergy.description = description
        allergy.save()
        return redirect('allergies')
    # Render the allergies page but include the allergy to edit so template shows edit form
    qs = Allergy.objects.filter(user=request.user)
    return render(request, 'allergies_form.html', {'allergies': qs, 'allergy': allergy})

