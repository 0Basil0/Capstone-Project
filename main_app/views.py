from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView, TemplateView
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth import logout
from .forms import CustomUserCreationForm
from .models import ChatHistory, Allergy
from django.db.models import Max
from django.views.decorators.http import require_POST
import requests
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
import json
import os
from google import genai
from django.shortcuts import get_object_or_404


class SignUpView(CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

def custom_logout(request):
    logout(request)
    return redirect('login')


@login_required
def post_login(request):
    # If user has no allergies recorded, send them to survey; otherwise go home
    if not Allergy.objects.filter(user=request.user).exists():
        return redirect('survey')
    return redirect('home')     


@login_required
def survey(request):
    return render(request, 'survey.html')


@login_required


def chatbot_api(request):
    if request.method == "POST":
        # Set API key in environment variable 
        os.environ["GEMINI_API_KEY"] = "AIzaSyBYsuwdWzG5Vm70uJ_AuzKljDES4FpUxyA"

        # Get user message...
        try:
            payload_json = json.loads(request.body)
            user_message = payload_json.get('message')
        except Exception:
            user_message = request.POST.get('message')
        if not user_message:
            return JsonResponse({"error": "No message provided"}, status=400)

        client = genai.Client()
        # Log user message...
        try:
            response = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=[{"parts": [{"text": user_message}]}],
            )

            reply = response.text
            if not reply:
                reply = str(response)

            # allow client to supply a session_id for continuing a conversation
            session_id = None
            try:
                payload = json.loads(request.body)
                session_id = payload.get('session_id')
            except Exception:
                session_id = request.POST.get('session_id')

            # Create a new ChatHistory row; if session_id provided, use it, else a new uuid is generated by model
            if session_id:
                chat = ChatHistory.objects.create(user=request.user, session_id=session_id, user_message=user_message, bot_response=reply)
            else:
                chat = ChatHistory.objects.create(user=request.user, user_message=user_message, bot_response=reply)

            return JsonResponse({"reply": reply, "session_id": str(chat.session_id)})
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=502)

@login_required
@require_POST
def survey_submit(request):
    # Process survey fields and save to DB
    first = request.POST.get('question1')
    last = request.POST.get('question2')
    age_raw = request.POST.get('question3')
    allergies_text = request.POST.get('question5')

    # Update user first/last name
    user = request.user
    if first:
        user.first_name = first
    if last:
        user.last_name = last
    user.save()

    # Save age 
    try:
        age = int(age_raw) if age_raw else None
    except ValueError:
        age = None
    if age is not None:
        from .models import Profile
        p, _ = Profile.objects.get_or_create(user=user)
        p.age = age
        p.save()

    # Save allergies
    if allergies_text:
        names = [n.strip() for n in allergies_text.split(',') if n.strip()]
        for name in names:
            try:
                Allergy.objects.get_or_create(user=user, name=name)
            except Allergy.MultipleObjectsReturned:
                qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                first = qs.first()
                qs.exclude(pk=first.pk).delete()

    return redirect('home')

@login_required
def base(request):
    return render (request, 'base.html')
@login_required
def home(request):
    return render (request, 'home.html')
class chatView(LoginRequiredMixin, ListView):
    model = ChatHistory
    
    template_name = 'chat_form.html'
    context_object_name = 'chats'

    def get(self, request, *args, **kwargs):
        # Get distinct session_ids and order them by the most recent message timestamp per session
        sessions = (
            ChatHistory.objects.filter(user=request.user)
            .values('session_id')
            .annotate(last_ts=Max('timestamp'))
            .order_by('-last_ts')
        )

        summaries = []
        for s in sessions:
            sid = s['session_id']
            entries = ChatHistory.objects.filter(user=request.user, session_id=sid).order_by('timestamp')
            if not entries.exists():
                continue
            first = entries.first()
            last = entries.last()

            preview_text = (last.bot_response or last.user_message or '')
            if len(preview_text) > 80:
                preview_text = preview_text[:77] + '...'

            summaries.append({
                'session_id': str(sid),
                'first_message': first.user_message,
                'preview': preview_text,
                'last_timestamp': last.timestamp,
            })

        return render(request, self.template_name, {'chats': summaries})
class AllergyListView(LoginRequiredMixin, ListView):
    model = Allergy
    
    template_name = 'allergies_form.html'
    context_object_name = 'allergies'
    def get_queryset(self):
        return Allergy.objects.filter(user=self.request.user)


@login_required
def chat_get(request, session_id):
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id).order_by('timestamp')
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    messages = []
    for chat in qs:
        messages.append({
            "id": chat.id,
            "user_message": chat.user_message,
            "bot_response": chat.bot_response,
            "timestamp": chat.timestamp.isoformat(),
        })
    return JsonResponse({"session_id": str(session_id), "messages": messages})


@login_required
@require_POST
def chat_delete(request, session_id):
    """Delete all chat history items in a session belonging to the user."""
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id)
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    qs.delete()
    return JsonResponse({"deleted": True})
