from django.shortcuts import render, redirect
from django.urls import reverse
from django.urls import reverse_lazy
from django.views.generic import ListView,  CreateView
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth import logout
from .forms import CustomUserCreationForm
from .models import ChatHistory, Allergy, MealPlan, Food
from django.db.models import Max
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.http import JsonResponse
import json
import os
from google import genai
from django.views.decorators.http import require_POST
from .utils import generate_daily_meals , generate_image
import datetime
import glob
import re
from django.db import connection, transaction, DatabaseError
from django.conf import settings
from django.utils.translation import get_language
from urllib.parse import urlparse, urlunparse


class SignUpView(CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

def custom_logout(request):
    logout(request)
    return redirect('login')






@login_required
def chatbot_api(request):
    if request.method == "POST":
        # Set API key in environment variable 
        os.environ["GEMINI_API_KEY"] = "AIzaSyBYsuwdWzG5Vm70uJ_AuzKljDES4FpUxyA"

        # Get user message...
        try:
            payload_json = json.loads(request.body)
            user_message = payload_json.get('message')
        except Exception:
            user_message = request.POST.get('message')
        if not user_message:
            return JsonResponse({"error": "No message provided"}, status=400)

        client = genai.Client()
        # Log user message...
        allergy_names = list(Allergy.objects.filter(user=request.user).values_list('name', flat=True))
        prompt = f"I am {request.user.first_name} and I have these allergies {allergy_names} depend on these information let your answer . this is the question {user_message}"
        try:
            response = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=[{"parts": [{"text": prompt}]}],
            )

            reply = response.text
            if not reply:
                reply = str(response)

            # allow client to supply a session_id for continuing a conversation
            session_id = None
            try:
                payload = json.loads(request.body)
                session_id = payload.get('session_id')
            except Exception:
                session_id = request.POST.get('session_id')

            # Create a new ChatHistory row; if session_id provided, use it, else a new uuid is generated by model
            if session_id:
                chat = ChatHistory.objects.create(user=request.user, session_id=session_id, user_message=user_message, bot_response=reply)
            else:
                chat = ChatHistory.objects.create(user=request.user, user_message=user_message, bot_response=reply)

            return JsonResponse({"reply": reply, "session_id": str(chat.session_id)})
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=502)

@login_required
def base(request):
    # Redirect root/base to the user's home dashboard
    return redirect('home')
@login_required
def home(request):
    return render (request, 'home.html')
class chatView(LoginRequiredMixin, ListView):
    model = ChatHistory
    
    template_name = 'chat_form.html'
    context_object_name = 'chats'

    # Get distinct session_ids and order them by the most recent message timestamp per session
    def get(self, request, *args, **kwargs):
        
        sessions = (
            ChatHistory.objects.filter(user=request.user)
            .values('session_id')
            .annotate(last_ts=Max('timestamp'))
            .order_by('-last_ts')
        )

        summaries = []
        for s in sessions:
            sid = s['session_id']
            entries = ChatHistory.objects.filter(user=request.user, session_id=sid).order_by('timestamp')
            if not entries.exists():
                continue
            first = entries.first()
            last = entries.last()

            preview_text = (last.bot_response or last.user_message or '')
            if len(preview_text) > 80:
                preview_text = preview_text[:77] + '...'

            summaries.append({
                'session_id': str(sid),
                'first_message': first.user_message,
                'preview': preview_text,
                'last_timestamp': last.timestamp,
            })

        # Ensure profile is available in template context
        profile = None
        try:
            profile = request.user.profile
        except Exception:
            profile = None
        return render(request, self.template_name, {'chats': summaries, 'profile': profile})


@login_required
def upload_avatar(request):
    # Simple endpoint to upload/change avatar from chat page.
    if request.method != 'POST':
        return redirect('chat')
    from .forms import ProfileAvatarForm
    # ensure profile exists (get_or_create returns (profile, created))
    from .models import Profile as ProfileModel
    profile_obj, _ = ProfileModel.objects.get_or_create(user=request.user)
    form = ProfileAvatarForm(request.POST, request.FILES, instance=profile_obj)
    if form.is_valid():
        form.save()
    return redirect('chat')


@login_required
def edit_profile(request):
    from .forms import ProfileForm
    profile_obj, _ = __import__('main_app.models', fromlist=['Profile']).Profile.objects.get_or_create(user=request.user)
    if request.method == 'POST':
        form = ProfileForm(request.POST, request.FILES, instance=profile_obj, user=request.user)
        if form.is_valid():
            form.save()
            return redirect('chat')
    else:
        form = ProfileForm(instance=profile_obj, user=request.user)
    return render(request, 'profile_edit.html', {'form': form})
class AllergyListView(LoginRequiredMixin, ListView):
    model = Allergy
    
    
    template_name = 'allergies_form.html'
    context_object_name = 'allergies'
    def get_queryset(self):
        return Allergy.objects.filter(user=self.request.user)


@login_required
def home(request):
    # Show today's meal placeholders and existing mealplans for user
    day = datetime.date.today().isoformat()

    # Avoid selecting all MealPlan columns (some DBs may be missing new columns like generation_count).
    plan_vals = MealPlan.objects.filter(user=request.user, day=day).values('breakfast_id', 'lunch_id', 'dinner_id').first()

    initial_plan = None
    # If there's no plan for today, fall back to the most recent saved plan so
    # previously generated images still appear on the dashboard.
    fallback_day = None
    if not plan_vals:
        latest_plan = MealPlan.objects.filter(user=request.user).order_by('-day').first()
        if latest_plan:
            plan_vals = {
                'breakfast_id': getattr(latest_plan, 'breakfast_id', None),
                'lunch_id': getattr(latest_plan, 'lunch_id', None),
                'dinner_id': getattr(latest_plan, 'dinner_id', None),
            }
            fallback_day = latest_plan.day

    if plan_vals:
        user_slug = request.user.username
        base_dir = os.path.dirname(os.path.abspath(__file__))
        # possible locations: MEDIA_ROOT (preferred for user-generated content) and app static folder
        media_root = getattr(settings, 'MEDIA_ROOT', None)
        media_base = os.path.join(media_root, 'images', 'generated', user_slug) if media_root else None
        static_base = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)

        # Use the day we looked up (today or fallback)
        lookup_day = fallback_day or day

        def image_url_if_exists_for_meal(meal_suffix):
            """Return a URL (/media/... or /static/...) for the most recent image for a meal, or None."""
            # search MEDIA first
            if media_base:
                pattern = os.path.join(media_base, f"{lookup_day}_*_{meal_suffix}.png")
                matches = glob.glob(pattern)
                if matches:
                    latest = max(matches, key=os.path.getmtime)
                    fname = os.path.basename(latest)
                    return os.path.join(settings.MEDIA_URL, 'images', 'generated', user_slug, fname).replace('\\', '/')
                legacy = os.path.join(media_base, f"{lookup_day}_{meal_suffix}.png")
                if os.path.exists(legacy):
                    return os.path.join(settings.MEDIA_URL, 'images', 'generated', user_slug, f"{lookup_day}_{meal_suffix}.png").replace('\\', '/')

            # fallback to app static folder
            pattern = os.path.join(static_base, f"{lookup_day}_*_{meal_suffix}.png")
            matches = glob.glob(pattern)
            if matches:
                latest = max(matches, key=os.path.getmtime)
                fname = os.path.basename(latest)
                return f"/static/images/generated/{user_slug}/{fname}"
            legacy = os.path.join(static_base, f"{lookup_day}_{meal_suffix}.png")
            if os.path.exists(legacy):
                return f"/static/images/generated/{user_slug}/{lookup_day}_{meal_suffix}.png"
            return None

        # Load Food objects by id (these are safe to query)
        breakfast = Food.objects.filter(pk=plan_vals.get('breakfast_id')).first() if plan_vals.get('breakfast_id') else None
        lunch = Food.objects.filter(pk=plan_vals.get('lunch_id')).first() if plan_vals.get('lunch_id') else None
        dinner = Food.objects.filter(pk=plan_vals.get('dinner_id')).first() if plan_vals.get('dinner_id') else None

        def strip_timestamp_suffix(name):
            if not name:
                return ''
            # remove trailing space + 14-digit timestamp (YYYYMMDDHHMMSS)
            return re.sub(r"\s*\d{14}$", '', name)

        # Build initial_plan including both 'en' and 'ar' values from stored Food rows when available.
        def make_bilingual_from_food(food_obj):
            if not food_obj:
                return {'name': {'en': '', 'ar': ''}, 'image': None, 'ingredients': {'en': '', 'ar': ''}, 'description': {'en': '', 'ar': ''}}
            name_en = strip_timestamp_suffix(food_obj.name) if food_obj.name else ''
            name_ar = getattr(food_obj, 'name_ar', '') or ''
            ings_en = food_obj.ingredients or ''
            ings_ar = getattr(food_obj, 'ingredients_ar', '') or ''
            desc_en = food_obj.description or ''
            desc_ar = getattr(food_obj, 'description_ar', '') or ''
            return {
                'name': {'en': name_en, 'ar': name_ar},
                'image': image_url_if_exists_for_meal('breakfast') if False else None, # placeholder, replaced below
                'ingredients': {'en': ings_en, 'ar': ings_ar},
                'description': {'en': desc_en, 'ar': desc_ar},
            }

        breakfast_bi = make_bilingual_from_food(breakfast)
        lunch_bi = make_bilingual_from_food(lunch)
        dinner_bi = make_bilingual_from_food(dinner)

        # set correct images
        if breakfast:
            breakfast_bi['image'] = image_url_if_exists_for_meal('breakfast')
        if lunch:
            lunch_bi['image'] = image_url_if_exists_for_meal('lunch')
        if dinner:
            dinner_bi['image'] = image_url_if_exists_for_meal('dinner')

        initial_plan = {
            'breakfast': breakfast_bi,
            'lunch': lunch_bi,
            'dinner': dinner_bi,
            'generation_count': 0,
        }

    import json
    initial_plan_json = json.dumps(initial_plan) if initial_plan else None
    # Build recent food history (last 5 MealPlan entries) so the homepage can show
    # previously generated meals in a compact history panel.
    food_history = []
    try:
        user_slug = request.user.username
        base_dir = os.path.dirname(os.path.abspath(__file__))
        media_root = getattr(settings, 'MEDIA_ROOT', None)
        media_base = os.path.join(media_root, 'images', 'generated', user_slug) if media_root else None
        static_base = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)

        def image_for(lookup_day, meal_suffix):
            # search MEDIA first
            if media_base:
                pattern = os.path.join(media_base, f"{lookup_day}_*_{meal_suffix}.png")
                matches = glob.glob(pattern)
                if matches:
                    latest = max(matches, key=os.path.getmtime)
                    fname = os.path.basename(latest)
                    return os.path.join(settings.MEDIA_URL, 'images', 'generated', user_slug, fname).replace('\\', '/')
                legacy = os.path.join(media_base, f"{lookup_day}_{meal_suffix}.png")
                if os.path.exists(legacy):
                    return os.path.join(settings.MEDIA_URL, 'images', 'generated', user_slug, f"{lookup_day}_{meal_suffix}.png").replace('\\', '/')

            # fallback to app static folder
            pattern = os.path.join(static_base, f"{lookup_day}_*_{meal_suffix}.png")
            matches = glob.glob(pattern)
            if matches:
                latest = max(matches, key=os.path.getmtime)
                fname = os.path.basename(latest)
                return f"/static/images/generated/{user_slug}/{fname}"
            legacy = os.path.join(static_base, f"{lookup_day}_{meal_suffix}.png")
            if os.path.exists(legacy):
                return f"/static/images/generated/{user_slug}/{lookup_day}_{meal_suffix}.png"
            return None

        recent_plans = MealPlan.objects.filter(user=request.user).order_by('-day')[:5]
        for p in recent_plans:
            entry = {
                'day': p.day,
                'breakfast': None,
                'lunch': None,
                'dinner': None,
            }
            if p.breakfast:
                entry['breakfast'] = {
                    'id': p.breakfast.id,
                    'name': {'en': re.sub(r"\s*\d{14}$", '', p.breakfast.name or ''), 'ar': getattr(p.breakfast, 'name_ar', '') or ''},
                    'image': image_for(p.day, 'breakfast')
                }
            if p.lunch:
                entry['lunch'] = {
                    'id': p.lunch.id,
                    'name': {'en': re.sub(r"\s*\d{14}$", '', p.lunch.name or ''), 'ar': getattr(p.lunch, 'name_ar', '') or ''},
                    'image': image_for(p.day, 'lunch')
                }
            if p.dinner:
                entry['dinner'] = {
                    'id': p.dinner.id,
                    'name': {'en': re.sub(r"\s*\d{14}$", '', p.dinner.name or ''), 'ar': getattr(p.dinner, 'name_ar', '') or ''},
                    'image': image_for(p.day, 'dinner')
                }
            food_history.append(entry)
    except Exception:
        food_history = []

    return render(request, 'home.html', {'initial_plan': initial_plan, 'initial_plan_json': initial_plan_json, 'food_history': food_history})


@login_required
@require_POST
def generate_and_save_meals(request):
    # Generate daily meals via AI and save them as Food + MealPlan for today


    allergy_names = list(Allergy.objects.filter(user=request.user).values_list('name', flat=True))
    meals_today = list(MealPlan.objects.filter(user=request.user).values_list('breakfast__name', 'lunch__name', 'dinner__name'))
    day = datetime.date.today().isoformat()
    data = generate_daily_meals(allergy_names=allergy_names, meals_today=meals_today)
    if not data:
        return JsonResponse({'error': 'Could not generate meals'}, status=502)

    # Helper to always create a new Food record for each generation so images and
    # DB entries are fresh every time the user clicks Generate.
    def create_new_food(obj):
        if not obj:
            return None
        # Helper: accept three possible shapes
        # 1) obj is a dict with keys 'name','ingredients','description' where each value is a string "EN // AR"
        # 2) obj is a dict with 'en' and 'ar' sub-dicts: {'en': {...}, 'ar': {...}}
        # 3) legacy single-language dict
        def split_en_ar(value):
            # Given a string (or None), return tuple (en, ar)
            if not value:
                return ('', '')
            if isinstance(value, dict):
                # value may already be {'en':..., 'ar':...}
                return (value.get('en','') or '', value.get('ar','') or '')
            s = str(value)
            # delimiter is '//' possibly with spaces
            if '//' in s:
                parts = s.split('//', 1)
                return (parts[0].strip(), parts[1].strip())
            return (s.strip(), '')

        name_en = ''
        name_ar = ''
        ings_en = ''
        ings_ar = ''
        desc_en = ''
        desc_ar = ''

        # Case: obj has 'en' and 'ar' dictionaries
        if isinstance(obj, dict) and obj.get('en') and obj.get('ar'):
            en = obj.get('en')
            ar = obj.get('ar')
            # en/ar may be sub-dicts or strings
            if isinstance(en, dict):
                name_en = (en.get('name') or '').strip()
                ings_en = (en.get('ingredients') or '').strip()
                desc_en = (en.get('description') or '').strip()
            else:
                # en could be string containing delimiter for the three fields; unlikely, but handle
                # best-effort: treat as name
                name_en = str(en).strip()
            if isinstance(ar, dict):
                name_ar = (ar.get('name') or '').strip()
                ings_ar = (ar.get('ingredients') or '').strip()
                desc_ar = (ar.get('description') or '').strip()
            else:
                name_ar = str(ar).strip()
        elif isinstance(obj, dict):
            # obj is likely {'name': 'EN // AR', 'ingredients': 'EN // AR', 'description': 'EN // AR'}
            name_field = obj.get('name')
            ings_field = obj.get('ingredients')
            desc_field = obj.get('description')
            name_en, name_ar = split_en_ar(name_field)
            ings_en, ings_ar = split_en_ar(ings_field)
            desc_en, desc_ar = split_en_ar(desc_field)
        else:
            # obj is a string containing combined fields? treat as name only
            name_en, name_ar = split_en_ar(obj)

        # Keep stored/display name clean (no timestamp suffix). Timestamp used in filenames.
        raw_name = name_en[:100].strip()

        food = Food.objects.create(
            name=raw_name,
            ingredients=ings_en,
            description=desc_en,
            name_ar=(name_ar or None),
            ingredients_ar=(ings_ar or None),
            description_ar=(desc_ar or None),
        )
        return food

    # Use a timestamp so each generation writes new image files
    ts = datetime.datetime.now().strftime('%Y%m%d%H%M%S')
    breakfast = create_new_food(data.get('breakfast', {})) if data.get('breakfast') else None
    lunch = create_new_food(data.get('lunch', {})) if data.get('lunch') else None
    dinner = create_new_food(data.get('dinner', {})) if data.get('dinner') else None
    print("Generated meals:", breakfast, lunch, dinner)

    # Generate background images for each meal and save into static/images/generated/<user>/<day>_
    user_slug = request.user.username
    day = datetime.date.today().isoformat()
    images = {}
    try:
        # ensure user's image directory exists under app static (backwards-compat)
        base_dir = os.path.dirname(os.path.abspath(__file__))
        images_folder = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)
        os.makedirs(images_folder, exist_ok=True)

        # also ensure MEDIA location exists if configured
        if getattr(settings, 'MEDIA_ROOT', None):
            media_images_folder = os.path.join(settings.MEDIA_ROOT, 'images', 'generated', user_slug)
            os.makedirs(media_images_folder, exist_ok=True)

        # generate images and let generate_image decide whether to save to MEDIA or static
        if breakfast:
            prompt = f"{breakfast.name}: {breakfast.ingredients}. {breakfast.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_breakfast.png"
            images['breakfast_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['breakfast_img'] = None

        if lunch:
            prompt = f"{lunch.name}: {lunch.ingredients}. {lunch.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_lunch.png"
            images['lunch_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['lunch_img'] = None

        if dinner:
            prompt = f"{dinner.name}: {dinner.ingredients}. {dinner.description}"
            img_rel = f"images/generated/{user_slug}/{day}_{ts}_dinner.png"
            images['dinner_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['dinner_img'] = None
    except Exception:
        images = {'breakfast_img': None, 'lunch_img': None, 'dinner_img': None}

    day = datetime.date.today().isoformat()
    plan, created = MealPlan.objects.get_or_create(user=request.user, day=day)
    plan.breakfast = breakfast
    plan.lunch = lunch
    plan.dinner = dinner
    # increment generation counter if field exists
    try:
        plan.generation_count = (plan.generation_count or 0) + 1
    except Exception:
        # if field missing or not available, ignore
        pass
    plan.save()

    # Return JSON with saved plan info
    return JsonResponse({
        'day': day,
        'breakfast': {
            'id': breakfast.id if breakfast else None,
            'name': {'en': breakfast.name if breakfast else '', 'ar': getattr(breakfast, 'name_ar', '') if breakfast else ''},
            'image': images.get('breakfast_img'),
            'ingredients': {'en': breakfast.ingredients if breakfast else '', 'ar': getattr(breakfast, 'ingredients_ar', '') if breakfast else ''},
            'description': {'en': breakfast.description if breakfast else '', 'ar': getattr(breakfast, 'description_ar', '') if breakfast else ''},
        },
        'lunch': {
            'id': lunch.id if lunch else None,
            'name': {'en': lunch.name if lunch else '', 'ar': getattr(lunch, 'name_ar', '') if lunch else ''},
            'image': images.get('lunch_img'),
            'ingredients': {'en': lunch.ingredients if lunch else '', 'ar': getattr(lunch, 'ingredients_ar', '') if lunch else ''},
            'description': {'en': lunch.description if lunch else '', 'ar': getattr(lunch, 'description_ar', '') if lunch else ''},
        },
        'dinner': {
            'id': dinner.id if dinner else None,
            'name': {'en': dinner.name if dinner else '', 'ar': getattr(dinner, 'name_ar', '') if dinner else ''},
            'image': images.get('dinner_img'),
            'ingredients': {'en': dinner.ingredients if dinner else '', 'ar': getattr(dinner, 'ingredients_ar', '') if dinner else ''},
            'description': {'en': dinner.description if dinner else '', 'ar': getattr(dinner, 'description_ar', '') if dinner else ''},
        },
    })
        


@login_required
def chat_get(request, session_id):
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id).order_by('timestamp')
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    messages = []
    for chat in qs:
        messages.append({
            "id": chat.id,
            "user_message": chat.user_message,
            "bot_response": chat.bot_response,
            "timestamp": chat.timestamp.isoformat(),
        })
    return JsonResponse({"session_id": str(session_id), "messages": messages})


@login_required
@require_POST
def chat_delete(request, session_id):
    # Delete all chat history items in a session belonging to the user.
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id)
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    qs.delete()
    return JsonResponse({"deleted": True})

@login_required
def add_allergy(request):
    allergies_text = request.POST.get('allergies')  
    user = request.user
    # Save allergies..
    if allergies_text:
            names = [n.strip() for n in allergies_text.split(',') if n.strip()]
            from .utils import generate_allergy_description
            for name in names:
                try:
                    desc = generate_allergy_description(name)
                    obj, created = Allergy.objects.get_or_create(user=user, name=name, defaults={'description': desc})
                    if not created and not obj.description and desc:
                        obj.description = desc
                        obj.save()
                except Allergy.MultipleObjectsReturned:
                    qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                    first = qs.first()
                    qs.exclude(pk=first.pk).delete()
                    if first and not first.description:
                        desc = generate_allergy_description(name)
                        if desc:
                            first.description = desc
                            first.save()
    return redirect('allergies')


@login_required
@require_POST
def delete_allergy(request, pk):
    # Only allow owner to delete
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    # to delete rows from the (possibly-missing) many-to-many join table.
    try:
        with transaction.atomic():
            with connection.cursor() as cursor:
                cursor.execute(
                    'DELETE FROM main_app_allergy WHERE id = %s AND user_id = %s',
                    [allergy.id, request.user.id]
                )
        # If this request came from fetch/ajax, return JSON so the client
        # doesn't follow redirects. Clients send X-Requested-With: XMLHttpRequest.
        if request.headers.get('x-requested-with') == 'XMLHttpRequest':
            return JsonResponse({'deleted': True})
        return redirect('allergies')
    except DatabaseError as e:
        # If SQL fails, fall back to ORM delete (this may still raise the original ProgrammingError)
        try:
            allergy.delete()
        except Exception as e2:
            if request.headers.get('x-requested-with') == 'XMLHttpRequest':
                return JsonResponse({"error": str(e2)}, status=400)
            return JsonResponse({"error": str(e2)}, status=400)
        if request.headers.get('x-requested-with') == 'XMLHttpRequest':
            return JsonResponse({'deleted': True})
        return redirect('allergies')


@login_required
def edit_allergy(request, pk):

    # Only allow owner to edit
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    if request.method == "POST":
        name = request.POST.get('name')
        description = request.POST.get('description')
        if name:
            allergy.name = name
        if description:
            allergy.description = description
        allergy.save()
        return redirect('allergies')
    # Render the allergies page but include the allergy to edit so template shows edit form
    qs = Allergy.objects.filter(user=request.user)
    return render(request, 'allergies_form.html', {'allergies': qs, 'allergy': allergy})

def toggle_language(request):
    """Simple GET-based language toggle. Accepts `?lang=xx` and optional `?next=` to redirect back.
    Sets the language cookie and redirects to the `next` URL or referrer.
    """
    lang = request.GET.get('lang')
    if not lang:
        # flip based on current active language
        current = get_language() or 'en'
        lang = 'ar' if not current.startswith('ar') else 'en'
    next_url = request.GET.get('next') or request.META.get('HTTP_REFERER') or reverse('home')

    # If next_url is absolute, preserve scheme/netloc. We'll operate on the path
    # and add/remove the language prefix ourselves because translate_url isn't
    # available in this environment's Django version.
    parsed = urlparse(next_url)
    path = parsed.path or '/'

    def _translate_path(path, target_lang):
        """Simple translation of a path by adding or removing the language prefix.

        This assumes URL patterns use i18n_patterns with a two-letter prefix like
        '/ar/'. It's intentionally minimal: it doesn't validate the path against
        URLconf, it only ensures the language segment is present or absent.
        """
        # normalize leading/trailing
        if not path.startswith('/'):
            path = '/' + path
        # list of language codes we support (from settings.LANGUAGES)
        supported = [c for c, _ in getattr(settings, 'LANGUAGES', [('en','English'), ('ar','Arabic')])]

        parts = path.split('/')
        # parts[0] == '' because path starts with '/'
        if len(parts) > 1 and parts[1] in supported:
            # path already has a language prefix
            current_pref = parts[1]
            if target_lang == current_pref:
                return path
            # replace prefix
            parts[1] = target_lang
            return '/'.join(parts) or '/'
        else:
            # no language prefix; if target is default language, return unchanged
            default = getattr(settings, 'LANGUAGE_CODE', 'en')[:2]
            if target_lang == default:
                return path
            # add prefix
            # ensure we avoid double slashes
            return '/' + target_lang + (path if path != '/' else '')

    translated_path = _translate_path(path, lang) or path

    if parsed.netloc:
        # Rebuild absolute URL with the translated path
        scheme = parsed.scheme or request.scheme
        netloc = parsed.netloc
        new_url = urlunparse((scheme, netloc, translated_path, parsed.params, parsed.query, parsed.fragment))
    else:
        # Relative URL: attach translated path and preserve query/fragment
        new_url = translated_path
        if parsed.query:
            new_url = new_url + '?' + parsed.query
        if parsed.fragment:
            new_url = new_url + '#' + parsed.fragment

    response = redirect(new_url)
    cookie_name = getattr(settings, 'LANGUAGE_COOKIE_NAME', 'django_language')
    # Use a session cookie (no max_age) so browser keeps preference until cleared
    response.set_cookie(cookie_name, lang)
    return response
