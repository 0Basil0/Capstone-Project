from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import ListView,  CreateView
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.auth import logout
from .forms import CustomUserCreationForm
from .models import ChatHistory, Allergy, MealPlan, Food
from django.db.models import Max
from django.views.decorators.http import require_POST
from django.http import JsonResponse
from django.shortcuts import get_object_or_404
from django.views.decorators.csrf import csrf_exempt
from django.http import JsonResponse
import json
import os
from google import genai
from django.views.decorators.http import require_POST



class SignUpView(CreateView):
    form_class = CustomUserCreationForm
    success_url = reverse_lazy('login')
    template_name = 'registration/signup.html'

def custom_logout(request):
    logout(request)
    return redirect('login')


@login_required
def post_login(request):
    # If user has no allergies recorded, send them to survey; otherwise go home
    if not Allergy.objects.filter(user=request.user).exists():
        return redirect('survey')
    return redirect('home')     


@login_required
def survey(request):
    return render(request, 'survey.html')


@login_required
def chatbot_api(request):
    if request.method == "POST":
        # Set API key in environment variable 
        os.environ["GEMINI_API_KEY"] = "AIzaSyBYsuwdWzG5Vm70uJ_AuzKljDES4FpUxyA"

        # Get user message...
        try:
            payload_json = json.loads(request.body)
            user_message = payload_json.get('message')
        except Exception:
            user_message = request.POST.get('message')
        if not user_message:
            return JsonResponse({"error": "No message provided"}, status=400)

        client = genai.Client()
        # Log user message...
        try:
            response = client.models.generate_content(
                model="gemini-2.5-flash",
                contents=[{"parts": [{"text": user_message}]}],
            )

            reply = response.text
            if not reply:
                reply = str(response)

            # allow client to supply a session_id for continuing a conversation
            session_id = None
            try:
                payload = json.loads(request.body)
                session_id = payload.get('session_id')
            except Exception:
                session_id = request.POST.get('session_id')

            # Create a new ChatHistory row; if session_id provided, use it, else a new uuid is generated by model
            if session_id:
                chat = ChatHistory.objects.create(user=request.user, session_id=session_id, user_message=user_message, bot_response=reply)
            else:
                chat = ChatHistory.objects.create(user=request.user, user_message=user_message, bot_response=reply)

            return JsonResponse({"reply": reply, "session_id": str(chat.session_id)})
        except Exception as e:
            return JsonResponse({"error": str(e)}, status=502)

@login_required
@require_POST
def survey_submit(request):
    # Process survey fields and save to DB
    first = request.POST.get('question1')
    last = request.POST.get('question2')
    age_raw = request.POST.get('question3')
    allergies_text = request.POST.get('question5')

    # Update user first/last name
    user = request.user
    if first:
        user.first_name = first
    if last:
        user.last_name = last
    user.save()

    # Save age 
    try:
        age = int(age_raw) if age_raw else None
        if age is not None and (age < 0 or age > 100):
            age = None
    except ValueError:
        age = None
    if age is not None:
        from .models import Profile
        p, _ = Profile.objects.get_or_create(user=user)
        p.age = age
        p.save()

    # Save allergies
    if allergies_text:
        names = [n.strip() for n in allergies_text.split(',') if n.strip()]
        from .utils import generate_allergy_description
        for name in names:
            try:
                desc = generate_allergy_description(name)
                obj, created = Allergy.objects.get_or_create(user=user, name=name, defaults={'description': desc})
                if not created and not obj.description and desc:
                    obj.description = desc
                    obj.save()
            except Allergy.MultipleObjectsReturned:
                qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                first = qs.first()
                qs.exclude(pk=first.pk).delete()
                if first and not first.description:
                    desc = generate_allergy_description(name)
                    if desc:
                        first.description = desc
                        first.save()

    return redirect('allergies')

@login_required
def base(request):
    return render (request, 'base.html')
@login_required
def home(request):
    return render (request, 'home.html')
class chatView(LoginRequiredMixin, ListView):
    model = ChatHistory
    
    template_name = 'chat_form.html'
    context_object_name = 'chats'

    # Get distinct session_ids and order them by the most recent message timestamp per session
    def get(self, request, *args, **kwargs):
        
        sessions = (
            ChatHistory.objects.filter(user=request.user)
            .values('session_id')
            .annotate(last_ts=Max('timestamp'))
            .order_by('-last_ts')
        )

        summaries = []
        for s in sessions:
            sid = s['session_id']
            entries = ChatHistory.objects.filter(user=request.user, session_id=sid).order_by('timestamp')
            if not entries.exists():
                continue
            first = entries.first()
            last = entries.last()

            preview_text = (last.bot_response or last.user_message or '')
            if len(preview_text) > 80:
                preview_text = preview_text[:77] + '...'

            summaries.append({
                'session_id': str(sid),
                'first_message': first.user_message,
                'preview': preview_text,
                'last_timestamp': last.timestamp,
            })

        return render(request, self.template_name, {'chats': summaries})
class AllergyListView(LoginRequiredMixin, ListView):
    model = Allergy
    
    
    template_name = 'allergies_form.html'
    context_object_name = 'allergies'
    def get_queryset(self):
        return Allergy.objects.filter(user=self.request.user)


@login_required
def home(request):
    # Show today's meal placeholders and existing mealplans for user
    import datetime, os
    day = datetime.date.today().isoformat()

    # Avoid selecting all MealPlan columns (some DBs may be missing new columns like generation_count).
    plan_vals = MealPlan.objects.filter(user=request.user, day=day).values('breakfast_id', 'lunch_id', 'dinner_id').first()

    initial_plan = None
    if plan_vals:
        user_slug = request.user.username
        base_dir = os.path.dirname(os.path.abspath(__file__))
        images_base = os.path.join(base_dir, 'static', 'images', 'generated', user_slug)

        def image_url_if_exists(fname):
            full = os.path.join(images_base, fname)
            if os.path.exists(full):
                return f"/static/images/generated/{user_slug}/{fname}"
            return None

        # Load Food objects by id (these are safe to query)
        breakfast = Food.objects.filter(pk=plan_vals.get('breakfast_id')).first() if plan_vals.get('breakfast_id') else None
        lunch = Food.objects.filter(pk=plan_vals.get('lunch_id')).first() if plan_vals.get('lunch_id') else None
        dinner = Food.objects.filter(pk=plan_vals.get('dinner_id')).first() if plan_vals.get('dinner_id') else None

        initial_plan = {
            'breakfast': {
                'name': breakfast.name if breakfast else '',
                'image': image_url_if_exists(f"{day}_breakfast.png"),
                'ingredients': breakfast.ingredients if breakfast else '',
                'description': breakfast.description if breakfast else '',
            },
            'lunch': {
                'name': lunch.name if lunch else '',
                'image': image_url_if_exists(f"{day}_lunch.png"),
                'ingredients': lunch.ingredients if lunch else '',
                'description': lunch.description if lunch else '',
            },
            'dinner': {
                'name': dinner.name if dinner else '',
                'image': image_url_if_exists(f"{day}_dinner.png"),
                'ingredients': dinner.ingredients if dinner else '',
                'description': dinner.description if dinner else '',
            },
            'generation_count': 0,
        }

    import json
    initial_plan_json = json.dumps(initial_plan) if initial_plan else None
    return render(request, 'home.html', {'initial_plan': initial_plan, 'initial_plan_json': initial_plan_json})


@login_required
@require_POST
def generate_and_save_meals(request):
    # Generate daily meals via AI and save them as Food + MealPlan for today
    from .utils import generate_daily_meals
    import datetime

    allergy_names = list(Allergy.objects.filter(user=request.user).values_list('name', flat=True))
    import datetime
    day = datetime.date.today().isoformat()
    data = generate_daily_meals(allergy_names=allergy_names)
    if not data:
        return JsonResponse({'error': 'Could not generate meals'}, status=502)

    # Helper to upsert Food
    def get_or_create_food(obj):
        name = obj.get('name')[:100]
        ingredients = obj.get('ingredients','')
        description = obj.get('description','')
        food, _ = Food.objects.get_or_create(name=name, defaults={'ingredients': ingredients, 'description': description})
        # update if missing
        changed = False
        if not food.ingredients and ingredients:
            food.ingredients = ingredients
            changed = True
        if not food.description and description:
            food.description = description
            changed = True
        if changed:
            food.save()
        return food

    breakfast = get_or_create_food(data.get('breakfast', {})) if data.get('breakfast') else None
    lunch = get_or_create_food(data.get('lunch', {})) if data.get('lunch') else None
    dinner = get_or_create_food(data.get('dinner', {})) if data.get('dinner') else None

    # Generate background images for each meal and save into static/images/generated/<user>/<day>_
    from .utils import generate_image
    user_slug = request.user.username
    day = datetime.date.today().isoformat()
    images = {}
    try:
        if breakfast:
            prompt = f"{breakfast.name}: {breakfast.ingredients}. {breakfast.description}"
            img_rel = f"images/generated/{user_slug}/{day}_breakfast.png"
            images['breakfast_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['breakfast_img'] = None
        if lunch:
            prompt = f"{lunch.name}: {lunch.ingredients}. {lunch.description}"
            img_rel = f"images/generated/{user_slug}/{day}_lunch.png"
            images['lunch_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['lunch_img'] = None
        if dinner:
            prompt = f"{dinner.name}: {dinner.ingredients}. {dinner.description}"
            img_rel = f"images/generated/{user_slug}/{day}_dinner.png"
            images['dinner_img'] = generate_image(prompt, output_path=img_rel)
        else:
            images['dinner_img'] = None
    except Exception:
        images = {'breakfast_img': None, 'lunch_img': None, 'dinner_img': None}

    day = datetime.date.today().isoformat()
    plan, created = MealPlan.objects.update_or_create(user=request.user, day=day, defaults={'breakfast': breakfast, 'lunch': lunch, 'dinner': dinner})

    # Return JSON with saved plan info
    return JsonResponse({
        'day': day,
        'breakfast': {
            'id': breakfast.id if breakfast else None,
            'name': breakfast.name if breakfast else '',
            'image': images.get('breakfast_img'),
            'ingredients': breakfast.ingredients if breakfast else '',
            'description': breakfast.description if breakfast else '',
        },
        'lunch': {
            'id': lunch.id if lunch else None,
            'name': lunch.name if lunch else '',
            'image': images.get('lunch_img'),
            'ingredients': lunch.ingredients if lunch else '',
            'description': lunch.description if lunch else '',
        },
        'dinner': {
            'id': dinner.id if dinner else None,
            'name': dinner.name if dinner else '',
            'image': images.get('dinner_img'),
            'ingredients': dinner.ingredients if dinner else '',
            'description': dinner.description if dinner else '',
        },
    })
        


@login_required
def chat_get(request, session_id):
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id).order_by('timestamp')
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    messages = []
    for chat in qs:
        messages.append({
            "id": chat.id,
            "user_message": chat.user_message,
            "bot_response": chat.bot_response,
            "timestamp": chat.timestamp.isoformat(),
        })
    return JsonResponse({"session_id": str(session_id), "messages": messages})


@login_required
@require_POST
def chat_delete(request, session_id):
    # Delete all chat history items in a session belonging to the user.
    qs = ChatHistory.objects.filter(user=request.user, session_id=session_id)
    if not qs.exists():
        return JsonResponse({"error": "Session not found"}, status=404)
    qs.delete()
    return JsonResponse({"deleted": True})

@login_required
def add_allergy(request):
    allergies_text = request.POST.get('allergies')  
    user = request.user
    # Save allergies..
    if allergies_text:
            names = [n.strip() for n in allergies_text.split(',') if n.strip()]
            from .utils import generate_allergy_description
            for name in names:
                try:
                    desc = generate_allergy_description(name)
                    obj, created = Allergy.objects.get_or_create(user=user, name=name, defaults={'description': desc})
                    if not created and not obj.description and desc:
                        obj.description = desc
                        obj.save()
                except Allergy.MultipleObjectsReturned:
                    qs = Allergy.objects.filter(user=user, name=name).order_by('id')
                    first = qs.first()
                    qs.exclude(pk=first.pk).delete()
                    if first and not first.description:
                        desc = generate_allergy_description(name)
                        if desc:
                            first.description = desc
                            first.save()
    return redirect('allergies')


@login_required
@require_POST
def delete_allergy(request, pk):
    # Only allow owner to delete
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    allergy.delete()
    return redirect('allergies')


@login_required
def edit_allergy(request, pk):
    # Only allow owner to edit
    allergy = get_object_or_404(Allergy, pk=pk, user=request.user)
    if request.method == "POST":
        name = request.POST.get('name')
        description = request.POST.get('description')
        if name:
            allergy.name = name
        if description:
            allergy.description = description
        allergy.save()
        return redirect('allergies')
    # Render the allergies page but include the allergy to edit so template shows edit form
    qs = Allergy.objects.filter(user=request.user)
    return render(request, 'allergies_form.html', {'allergies': qs, 'allergy': allergy})